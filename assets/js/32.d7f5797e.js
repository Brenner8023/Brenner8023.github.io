(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{197:function(_,v,t){"use strict";t.r(v);var a=t(0),e=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"数据库学习笔记-三"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库学习笔记-三","aria-hidden":"true"}},[_._v("#")]),_._v(" 数据库学习笔记(三)")]),_._v(" "),t("p",[_._v("Updated December 27, 2018")]),_._v(" "),t("p",[t("a",{attrs:{name:"04467815"}})]),_._v(" "),t("h1",{attrs:{id:"数据库恢复技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库恢复技术","aria-hidden":"true"}},[_._v("#")]),_._v(" 数据库恢复技术")]),_._v(" "),t("p",[_._v("事务: 是用户定义的一个数据库操作序列, 这些操作要么全做, 要么全不做, 是一个不可分割的工作单位")]),_._v(" "),t("p",[_._v("事务的特性")]),_._v(" "),t("ol",[t("li",[_._v("原子性: 事务中包括的诸操作要么都做, 要么都不做")]),_._v(" "),t("li",[_._v("一致性: 如果数据库系统运行中发生故障, 有些事务尚未完成就被迫中断, 这些未完成的事务对数据库所做的修改有一部分已写入, 这时数据库就处于一种不一致的状态")]),_._v(" "),t("li",[_._v("隔离性: 一个事务的执行不能被其他事务干扰")]),_._v(" "),t("li",[_._v("持续性: 指一个事务一旦提交, 它对数据库中数据的改变就应该是永久性的")])]),_._v(" "),t("p",[_._v("故障的种类:")]),_._v(" "),t("ul",[t("li",[_._v("事务内部的故障")])]),_._v(" "),t("p",[_._v("(1)反向扫描日志文件, 查找该事务的更新操作")]),_._v(" "),t("p",[_._v("(2)对该事物的更新操作进行逆操作")]),_._v(" "),t("p",[_._v("(3)继续反向扫描日志文件")]),_._v(" "),t("p",[_._v("(4)直至读到此事务的开始标记.")]),_._v(" "),t("ul",[t("li",[_._v("系统故障:")])]),_._v(" "),t("p",[_._v("(1)正向扫描日志文件, 找出在故障发生前已经提交的事务, 将其事务标识记入重做队列. 同时找出故障发生时尚未完成的事务, 将其事务标识记入撤销队列")]),_._v(" "),t("p",[_._v("(2)对撤销队列中每个事务进行撤销处理")]),_._v(" "),t("p",[_._v("(3)对重做队列中各个事务进行重做处理")]),_._v(" "),t("ul",[t("li",[_._v("介质故障:")])]),_._v(" "),t("p",[_._v("(1)装入离故障发生时刻最近的转储副本")]),_._v(" "),t("p",[_._v("(2)装入相应的日志文件副本, 重做已完成的事务")]),_._v(" "),t("ul",[t("li",[_._v("计算机病毒")])]),_._v(" "),t("p",[t("a",{attrs:{name:"6e996c8b"}})]),_._v(" "),t("h3",{attrs:{id:"建立冗余数据最常用的技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建立冗余数据最常用的技术","aria-hidden":"true"}},[_._v("#")]),_._v(" 建立冗余数据最常用的技术:")]),_._v(" "),t("p",[_._v("数据转储")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th"),_._v(" "),t("th",[_._v("动态转储")]),_._v(" "),t("th",[_._v("静态转储")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("海量转储")]),_._v(" "),t("td",[_._v("动态海量转储")]),_._v(" "),t("td",[_._v("静态海量转储")])]),_._v(" "),t("tr",[t("td",[_._v("增量转储")]),_._v(" "),t("td",[_._v("动态增量转储")]),_._v(" "),t("td",[_._v("静态增量转储")])])])]),_._v(" "),t("p",[_._v("静态转储: 在系统中无运行事务时进行")]),_._v(" "),t("p",[_._v("动态转储: 指转储期间允许对数据库进行存取或修改")]),_._v(" "),t("p",[_._v("海量转储: 指每次转储全部数据库")]),_._v(" "),t("p",[_._v("增量转储: 指每次只转储上一次转储后更新过的数据")]),_._v(" "),t("p",[_._v("登记日志文件")]),_._v(" "),t("ul",[t("li",[_._v("登记的次序严格按并发事务执行的时间次序")]),_._v(" "),t("li",[_._v("必须先写日志文件, 后写数据库")])]),_._v(" "),t("p",[t("a",{attrs:{name:"5a9d7500"}})]),_._v(" "),t("h1",{attrs:{id:"并发控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发控制","aria-hidden":"true"}},[_._v("#")]),_._v(" 并发控制")])])}],!1,null,null,null);v.default=e.exports}}]);